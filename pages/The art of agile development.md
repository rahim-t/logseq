---
title: The art of agile development
---

## Metadata::
### Author(s):: [[James Shore]], [[Shane Warden]]

### Type:: [[Book]]

### Topics:: [[Informatik]], [[Produktivität, Unternehmertum, Management]]

### Date:: 2008

### Date added:: [[July 2nd, 2019]]

### Zotero links:: [Local library](zotero://select/library/items/CUJZLPPH), [Web library](https://www.zotero.org/users/4111725/items/CUJZLPPH), [Shore_Warden_2008_The art....pdf](zotero://open-pdf/library/items/8SYVQEWS)

### tag:: #[[Exzerpt]], #[[ZoteroImport]]

## Notes::
### **[[Yellow Annotations]] (17/07/2019, 12:02:29)**
#### "I fully expect the big consulting companies to start offering Certified Agile Processes and Certified Agile Consultants—for astronomical fees, of course—any day now. Please don't get sucked into that mess. In 1986, [Brooks] famously predicted that there were no silver bullets: that by 1996, no single technology or management technique would offer a tenfold increase in productivity, reliability, or simplicity. None did. Agile development isn't a silver bullet, either. In fact, I don't recommend adopting agile development solely to increase productivity. Its benefits— even the ability to release software more frequently—come from working differently, not from working faster . Although anecdotal evidence indicates that agile teams have above-average productivity, that shouldn't be your primary motivation. Your team will need time to learn agile development. While they learn—and it will take a quarter or two—they'll go slower, not faster. In addition, emphasizing productivity might encourage your team to take shortcuts and to be less rigorous in their work, which could actually harm productivity." ([Shore and Warden 2008:22](zotero://open-pdf/library/items/8SYVQEWS?page=22))

#### "Agile development focuses on achieving personal, technical, and organizational successes." ([Shore and Warden 2008:25](zotero://open-pdf/library/items/8SYVQEWS?page=25))

#### "Agile methods are processes that support the agile philosophy. Examples include Extreme Programming and Scrum. Agile methods consist of individual elements called practices. Practices include using version control, setting coding standards, and giving weekly demos to your stakeholders." ([Shore and Warden 2008:28](zotero://open-pdf/library/items/8SYVQEWS?page=28))

#### "One of the most astonishing premises of XP is that you can eliminate requirements, design, and testing phases as well as the formal documents that go with them. [...] Software projects do need more requirements, design, and testing—which is why XP teams work on these activities every day. [...] XP emphasizes face-to-face collaboration. [...] Using simultaneous phases, an XP team produces deployable software every week. In each iteration, the team analyzes, designs, codes, tests, and deploys a subset of features. Although this approach doesn't necessarily mean that the team is more productive, it does mean that the team gets feedback much more frequently." ([Shore and Warden 2008:37](zotero://open-pdf/library/items/8SYVQEWS?page=37))

#### "XP does it by working in iterations: week-long increments of work. Every week, the team does a bit of release planning, a bit of design, a bit of coding, a bit of testing, and so forth. They work on stories: very small features, or parts of features, that have customer value. Every week, the team commits to delivering four to ten stories. [...] Every XP team includes several business experts—the on-site customers—who are responsible for making business decisions." ([Shore and Warden 2008:38](zotero://open-pdf/library/items/8SYVQEWS?page=38))

#### "XP teams sit together in an open workspace. At the beginning of each iteration, the team meets for a series of activities: an iteration demo, a retrospective, and iteration planning. These typically take two to four hours in total. The team also meets for daily stand-up meetings, which usually take five to ten minutes each. Other than these scheduled activities, everyone on the team plans his own work." ([Shore and Warden 2008:47](zotero://open-pdf/library/items/8SYVQEWS?page=47))

#### "four to six programmers is a good starting point. Applying the staffing guidelines to a team of 6 programmers produces a team that also includes 4 customers, 1 tester, and a project manager, for a total team size of 12 people. Twelve people turns out to be a natural limit for team collaboration." ([Shore and Warden 2008:57](zotero://open-pdf/library/items/8SYVQEWS?page=57))

#### "All the team members should sit with the team full-time and give the project their complete attention. This particularly applies to customers, who are often surprised by the level of involvement XP requires of them." ([Shore and Warden 2008:58](zotero://open-pdf/library/items/8SYVQEWS?page=58))

#### "Refactoring is the process of changing the structure of code—rephrasing it—without changing its meaning or behavior. It's used to improve code quality, to fight off software's unavoidable entropy, and to ease adding new features. [...] Left unchecked, technical debt grows to overwhelm software projects. Software costs millions of dollars to develop, and even small projects cost hundreds of thousands. It's foolish to throw away that investment and rewrite the software, but it happens all the time. Why? Unchecked technical debt makes the software more expensive to modify than to reimplement. What a waste. XP takes a fanatical approach to technical debt. The key to managing it is to be constantly vigilant. Avoid shortcuts, use simple design, refactor relentlessly... [...] If you use timeboxing, you set aside a specific block of time for your research or discussion and stop when your time is up, regardless of your progress." ([Shore and Warden 2008:59](zotero://open-pdf/library/items/8SYVQEWS?page=59))

#### "easily changed design is XP's core enabler. This means at least one person on the team— preferably a natural leader—needs to have strong design skills. [...] domain-driven design. It requires a crucial shift in thinking—from imperative procedural design to declarative object-oriented design [...]. [Evans]' Domain-Driven Design is a good place to start, as is [Fowler 2002a]'s Patterns of Enterprise Application Architecture ." ([Shore and Warden 2008:68](zotero://open-pdf/library/items/8SYVQEWS?page=68))

#### "object-oriented and dynamic languages with garbage collection are the easiest to refactor. C and C++, for example, are more difficult to refactor." ([Shore and Warden 2008:69](zotero://open-pdf/library/items/8SYVQEWS?page=69))

#### "Pair programming is one of the first things people notice about XP. Two people working at the same keyboard? It's weird. It's also extremely powerful and, once you get used to it, tons of fun. [...] When you pair, one person codes—the driver. The other person is the navigator, whose job is to think. [...] One study found that pairing takes about 15 percent more effort than one individual working alone, but produces results more quickly and with 15 percent fewer defects" ([Shore and Warden 2008:90](zotero://open-pdf/library/items/8SYVQEWS?page=90))

#### "A good rule of thumb is to pair on anything that you need to maintain, which includes tests and the build script. [...] Never assign partners: pairs are fluid, forming naturally and shifting throughout the day. Over time, pair with everyone on the team. [...] When you need a fresh perspective, switch partners. I usually switch when I'm feeling frustrated or stuck. Have one person stay on the task and bring the new partner up to speed. Often, even explaining the problem to someone new will help you resolve it. It's a good idea to switch partners several times per day even if you don't feel stuck. This will help keep everyone informed and moving quickly. I switch whenever I finish a task. If I'm working on a big task, I switch within four hours." ([Shore and Warden 2008:91](zotero://open-pdf/library/items/8SYVQEWS?page=91))

#### "I like to plug in two keyboards and mice so each person can have a set. Splurge on large monitors so that both people can see clearly. Some teams mirror the display onto two monitors, which makes things a little easier to see, but you may find yourself pointing to the wrong monitor. Others prefer to spread one desktop across two monitors." ([Shore and Warden 2008:92](zotero://open-pdf/library/items/8SYVQEWS?page=92))

#### "if you know you'll be pairing with a junior developer, you can ask him to research a topic that no one else knows, such as the inner workings of a library that the team depends on. Give everyone a chance to be an expert." ([Shore and Warden 2008:93](zotero://open-pdf/library/items/8SYVQEWS?page=93))

#### "you will still produce code that you don't need to maintain. (Spike solutions are one example.) These may benefit from individual study. Some production tasks are so repetitive that they don't require the extra brainpower a pair provides. Before abandoning pairing, however, consider why your design requires so much repetition. It could be an indication of a design flaw." ([Shore and Warden 2008:94](zotero://open-pdf/library/items/8SYVQEWS?page=94))

#### "Some teams revert (delete) code that doesn't pass all its tests at the end of the day. This sounds harsh, but it's a good idea: if you can't easily check in, you've gone far off track. You'll do better work in the morning. If you're practicing continuous integration well, the loss of code will be minimal and you'll still have learned from the experience." ([Shore and Warden 2008:100](zotero://open-pdf/library/items/8SYVQEWS?page=100))

#### "Try providing a free meal once per week." ([Shore and Warden 2008:122](zotero://open-pdf/library/items/8SYVQEWS?page=122))

#### "The sample workspace in Figure 6-2 was designed for a team of 13. They had six programmers, six pairing stations, and a series of cubbies for personal effects. Nonprogrammers worked close to the pairing stations so they could be part of the conversation even when they weren't pairing. Programmers' cubbies were at the far end because they typically sat at the pairing stations. For privacy, people adjourned to the far end of the workspace or went to one of the small conference rooms down the hall. In addition to the pairing stations, everybody had a laptop for personal work and email. The pairing stations all used a group login so any team member could work at them." ([Shore and Warden 2008:135](zotero://open-pdf/library/items/8SYVQEWS?page=135))

#### "They had a team of seven: six programmers and a product manager. This team arranged its five pairing stations along a long wall. They had a table on the side for meetings, and charts and whiteboards on dividers surrounded them. The programmers had a pod of half-cubicles on the other side for personal effects, and there were small conference rooms close by for privacy. This was a great workspace with one serious problem: the product manager wasn't in earshot and didn't participate in team discussion. The team couldn't get ready answers to its questions and often struggled with requirements." ([Shore and Warden 2008:136](zotero://open-pdf/library/items/8SYVQEWS?page=136))

#### "For programmers, pair programming is an excellent way to focus your attention away from the background noise. You won't notice it if you're pairing. [...] Some teams have a bell for team members to ring when they want the team to be more quiet." ([Shore and Warden 2008:137](zotero://open-pdf/library/items/8SYVQEWS?page=137))

#### "• "done done" ensures that completed work is ready to release. • No bugs allows you to release your software without a separate testing phase. • Version control allows team members to work together without stepping on each other's toes. • A ten-minute build builds a tested release package in under 10 minutes. • Continuous integration prevents a long, risky integration phase. • Collective code ownership allows the team to solve problems no matter where they may lie.• Post-hoc documentation decreases the cost of documentation and increases its accuracy." ([Shore and Warden 2008:172f](zotero://open-pdf/library/items/8SYVQEWS?page=172))

#### "Create a checklist that shows the story completion criteria [...]:

#### • Tested (all unit, integration, and customer tests finished) • Coded (all code written) • Designed (code refactored to the team's satisfaction) • Integrated (the story works from end to end—typically, UI to database—and fits into the rest of the software) • Builds (the build script includes any new modules) • Installs (the build script includes the story in the automated installer) • Migrates (the build script updates database schema if necessary; the installer migrates data when appropriate) • Reviewed (customers have reviewed the story and confirmed that it meets their expectations) • Fixed (all known bugs have been fixed or scheduled as their own stories) • Accepted (customers agree that the story is finished) Some teams add "Documented" to this list, meaning that the story has documentation and help text. This is most appropriate when you have a technical writer as part of your team. Other teams include "Performance" and "Scalability" in their "done done" list, but these can lead to premature optimization. I prefer to schedule performance, scalability, and similar issues with dedicated stories." ([Shore and Warden 2008:175f](zotero://open-pdf/library/items/8SYVQEWS?page=175))

#### "XP works best when you make a little progress on every aspect of your work every day, rather than reserving the last few days of your iteration for getting stories "done done."" ([Shore and Warden 2008:176](zotero://open-pdf/library/items/8SYVQEWS?page=176))

#### "Branches work best when they are short-lived or when you use them for small numbers of changes. If you support old versions of your software, a branch for each version is the best place to put bug fixes and minor enhancements for those versions. Some teams create a branch in preparation for a release. Half the team continues to perform new work, and the other half attempts to stabilize the old version. In XP, your code shouldn't require stabilization, so it's more useful to create such a branch at the point of release, not in preparation for release. [...] Branches can also be useful for continuous integration and other code management tasks. These private branches live for less than a day" ([Shore and Warden 2008:193](zotero://open-pdf/library/items/8SYVQEWS?page=193))

#### "Releasing frequently doesn't mean setting aggressive deadlines. In fact, aggressive deadlines extend schedules rather than reducing them [...]. Instead, release more often by including less in each release. [...] A minimum marketable feature, or MMF, is the smallest set of functionality that provides value to your market." ([Shore and Warden 2008:228](zotero://open-pdf/library/items/8SYVQEWS?page=228))

#### "XP assumes that customers have the most information about value: what best serves the organization. Programmers have the most information about costs: what it will take to implement and maintain those features. [...] Because programmers have the most information about costs—they're most qualified to say how long it will take to implement a story—they [[estimate [[Stories]]]]. Because customers have the most information about value—they're most qualified to say what is important—they prioritize.

#### [...]

#### 1. Anyone creates a story or selects an unplanned story. 2. Programmers [[estimate [[Stories]]]] the story. 3. Customers place the story into the plan in order of its relative priority. 4. The steps are repeated until all stories have been [[estimate [[Stories]]]]d and placed into the plan." ([Shore and Warden 2008:238](zotero://open-pdf/library/items/8SYVQEWS?page=238))

#### "Iterations follow a consistent, unchanging schedule:

#### • Demonstrate previous iteration (up to half an hour) • Hold retrospective on previous iteration (one hour) • Plan iteration (half an hour to four hours) • Commit to delivering stories (five minutes) • Develop stories (remainder of iteration) • Prepare release (less than 10 minutes)" ([Shore and Warden 2008:252](zotero://open-pdf/library/items/8SYVQEWS?page=252))

#### "Stories may be the most misunderstood entity in all of XP. They're not requirements. They're not use cases. They're not even narratives. They're much simpler than that. Stories are for planning. They're simple one- or two-line descriptions of work the team should produce. Alistair Cockburn calls them "promissory notes for future conversation." [...].
:PROPERTIES:
:ID:a47021a7-3b62-488f-baef-b2e7f981fbb2
:END:

#### 1. Stories represent customer value and are written in the customers' terminology. (The best stories are actually written by customers.) They describe an end-result that the customer values, not implementation details. 2. Stories have clear completion criteria. Customers can describe an objective test that would allow programmers to tell when they've successfully implemented the story." ([Shore and Warden 2008:272](zotero://open-pdf/library/items/8SYVQEWS?page=272))
:PROPERTIES:
:ID:c859a099-91a2-4720-bb28-cb6609eb76f5
:END:

#### "Sometimes programmers won't be able to estimate a story because they don't know enough about the technology required to implement the story. In this case, create a story to research that technology." ([Shore and Warden 2008:275](zotero://open-pdf/library/items/8SYVQEWS?page=275))

#### "It's much more difficult to create customer-centric stories than programmer-centric stories" ([Shore and Warden 2008:277](zotero://open-pdf/library/items/8SYVQEWS?page=277))

#### "[[estimate [[Stories]]]] stories in story points. To begin, think of a story point as an ideal day. It's OK to [[estimate [[Stories]]]] in half-points, but quarter-points shouldn't be necessary." ([Shore and Warden 2008:282](zotero://open-pdf/library/items/8SYVQEWS?page=282))

#### "The best way I know to reduce the cost of writing software is to improve the internal quality of its code and design. I've never seen high quality on a well-managed project fail to repay its investment." ([Shore and Warden 2008:290](zotero://open-pdf/library/items/8SYVQEWS?page=290))

#### "fast that errors are easy to find and fix. If something doesn't compile, there isn't much code to check. Test-driven development applies the same principle to programmer intent. Just as modern compilers provide more feedback on the syntax of your code, TDD cranks up the feedback on the execution of your code. Every few minutes—as often as every 20 or 30 seconds—TDD verifies that the code does what you think it should do. If something goes wrong, there are only a few lines of code to check. [...] TDD uses an approach similar to double-entry bookkeeping. You communicate your intentions twice, stating the same idea in different ways: first with a test, then with production code. When they match, it's likely they were both coded correctly." ([Shore and Warden 2008:304](zotero://open-pdf/library/items/8SYVQEWS?page=304))

#### "The XP saying is, "Don't write any production code unless you have a failing test." Your first step, therefore, is to engage in a rather odd thought process. Imagine what behavior you want your code to have, then think of a small increment that will require fewer than five lines of code. Next, think of a test—also a few lines of code—that will fail unless that behavior is present. In other words, think of a test that will force you to add the next few lines of production code. This is the hardest part of TDD because the concept of tests driving your code seems backward, and because it can be difficult to think in small increments." ([Shore and Warden 2008:305](zotero://open-pdf/library/items/8SYVQEWS?page=305))

#### "Pair programming helps. While the driver tries to make the current test pass, the navigator should stay a few steps ahead, thinking of tests that will drive the code to the next increment. [...] Code in terms of the class' behavior and its public interface, not how you think you will implement the internals of the class. Respect encapsulation. In the first few tests, this often means you write your test to use method and class names that don't exist yet. This is intentional—it forces you to design your class' interface from the perspective of a user of the class, not as its implementer. After the test is coded, run your entire suite of tests and watch the new test fail. In most TDD testing tools, this will result in a red progress bar. [...] Don't worry about design purity or conceptual elegance—just do what you need to do to make the test pass. Sometimes you can just hardcode the answer." ([Shore and Warden 2008:306](zotero://open-pdf/library/items/8SYVQEWS?page=306))

#### "If the test fails, get back to known-good code as quickly as you can. Often, you or your pairing partner can see the problem by taking a second look at the code you just wrote. If you can't see the problem, consider erasing the new code and trying again. Sometimes it's best to delete the new test (it's only a few lines of code, after all) and start the cycle over with a smaller increment. [...] With all your tests passing again, you can now refactor without worrying about breaking anything. Review the code and look for possible improvements." ([Shore and Warden 2008:307](zotero://open-pdf/library/items/8SYVQEWS?page=307))

#### "I've learned through painful experience that I can break nearly anything, so I test nearly everything. The only exception is code without any logic, such as simple accessors and mutators (getters and setters), or a method that only calls another method. You don't need to test third-party code unless you have some reason to distrust it. [...] If your code is so complex that you need to test a private method directly, this may be a sign that you should refactor. You may benefit from moving the private methods into their own class and providing a public interface. [...] TDD is particularly difficult with user interfaces because most UI frameworks weren't designed with testability in mind. Many people compromise by writing a very thin, untested translation layer that only forwards UI calls to a presentation layer. They keep all their UI logic in the presentation layer and use TDD on that layer as normal. There are some tools that allow you to test a UI directly, perhaps by making HTTP calls (for web-based software), or by pressing buttons or simulating window events (for client-based software). These are essentially integration tests, and they suffer similar speed and maintainability challenges as other integration tests. Despite the challenges, these tools can be helpful." ([Shore and Warden 2008:320](zotero://open-pdf/library/items/8SYVQEWS?page=320))

#### "Although TDD is a very valuable tool, it does have a two- or three-month learning curve. [...] TDD is the heart of XP's programming practices. Without it, all of XP's other technical practices will be much harder to use. A common misinterpretation of TDD is to design your entire class first, then write all its test methods, then write the code. This approach is frustrating and slow, and it doesn't allow you to learn as you go. Another misguided approach is to write your tests after you write your production code. This is very difficult to do well—production code must be designed for testability, and it's hard to do so unless you write the tests first. It doesn't help that writing tests after the fact is boring. In practice, the temptation to move on to the next task usually overwhelms the desire for well-tested code. Although you can use these alternatives to introduce tests to your code, TDD isn't just about testing. It's really about using very small increments to produce high-quality, known-good code. I'm not aware of any alternatives that provide TDD's ability to catch and fix mistakes quickly." ([Shore and Warden 2008:321](zotero://open-pdf/library/items/8SYVQEWS?page=321))

#### "A spike solution, or spike, is a technical investigation. It's a small experiment to research the answer to a problem. [...] Although this example is written as a standalone program, small spikes such as this one can also be written inside your test framework. Although they don't actually call your production code, the test framework provides a convenient way to quickly run the spike and report on the results." ([Shore and Warden 2008:350](zotero://open-pdf/library/items/8SYVQEWS?page=350))

#### "I discard the spikes I create to clarify a technical question (such as "Does this language throw an exception on arithmetic overflow?"), but generally keep the ones that demonstrate how to accomplish a specific task (such as "How do I send HTML email?"). I keep a separate spikes/ directory in my repository just for these sorts of spikes." ([Shore and Warden 2008:351](zotero://open-pdf/library/items/8SYVQEWS?page=351))

#### "Simplicity is the art of maximizing the work not done." ([Shore and Warden 2008:389](zotero://open-pdf/library/items/8SYVQEWS?page=389))
